from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field, ConfigDict
import uuid

class FormattedResults(BaseModel):
    status: str
    headers: List[str]
    rows: List[Dict[str, Any]]
    total_rows: int

class LogTokens(BaseModel):
    """Token usage tracking for agent responses"""
    input_tokens: int = 0
    output_tokens: int = 0
    input_cost: float = 0.0
    output_cost: float = 0.0
    total_tokens: int = 0

class AgentResponse(BaseModel):
    agent_type: str
    response: str
    success: bool = True
    error_message: Optional[str] = None
    processing_time_ms: Optional[int] = None
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    formatted_results: Optional[FormattedResults] = Field(None, description="Formatted results for UI or downstream processing")
    summary: Optional[Any] = Field(None, description="Summary or insights generated by the agent")
    insights: Optional[Any] = Field(None, description="Additional insights if present")
    recommendations: Optional[Any] = Field(None, description="Business or technical recommendations")
    tokens: Optional[LogTokens] = None
    execution_time_ms: Optional[int] = None
    
    def model_dump(self, **kwargs):
        """Custom model_dump method to handle datetime serialization"""
        data = super().model_dump(**kwargs)
        if 'timestamp' in data and isinstance(data['timestamp'], datetime):
            data['timestamp'] = data['timestamp'].isoformat()
        return data

class UserSession(BaseModel):
    """User session model for Cosmos DB storage"""
    session_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_id: str
    start_time: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    last_activity: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    end_time: Optional[datetime] = None
    total_turns: int = 0
    is_active: bool = True
    session_metadata: Dict[str, Any] = Field(default_factory=dict)
    
    @property
    def id(self) -> str:
        """Use session_id as the document id for Cosmos DB"""
        return self.session_id
    
    @property
    def partition_key(self) -> str:
        """Simple partition key for backward compatibility"""
        return self.user_id
    
    def model_dump(self, **kwargs):
        """Custom model_dump method to handle datetime serialization"""
        data = super().model_dump(**kwargs)
        for field in ['start_time', 'last_activity', 'end_time']:
            if field in data and data[field] is not None:
                if isinstance(data[field], datetime):
                    data[field] = data[field].isoformat()
        return data

class ChatLogEntry(BaseModel):
    """Enhanced chat log entry model with hierarchical partitioning support"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    session_id: str
    user_id: str
    user_input: str
    agent_responses: List[AgentResponse] = Field(default_factory=list)
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    conversation_turn: int = 1
    vector_cache_hit: bool = False
    processing_time_ms: Optional[int] = None
    
    @property
    def partition_key(self) -> str:
        """Hierarchical partition key for better Cosmos DB distribution"""
        return f"{self.user_id}/{self.session_id}"
    
    def model_dump(self, **kwargs):
        """Custom model_dump method to handle datetime serialization"""
        data = super().model_dump(**kwargs)
        # Convert datetime objects to ISO format strings
        if 'timestamp' in data and isinstance(data['timestamp'], datetime):
            data['timestamp'] = data['timestamp'].isoformat()
        for response in data.get('agent_responses', []):
            if 'timestamp' in response and isinstance(response['timestamp'], datetime):
                response['timestamp'] = response['timestamp'].isoformat()
        return data

    class Config:
        model_config = ConfigDict(
            json_encoders={
                datetime: lambda v: v.isoformat()
            }
        )